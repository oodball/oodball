const fs = require('fs');
const path = require('path');
const vm = require('vm');

const ENTRIES_DIR = path.join(__dirname, '../src/entries');
const MANIFEST_FILE = path.join(ENTRIES_DIR, 'manifest.js');

// Read and parse an entry file to extract metadata
function parseEntryFile(filePath, fileName) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    
    // Extract the export statement - look for "export const {name} = {"
    const exportMatch = content.match(/export\s+const\s+(\w+)\s*=/);
    if (!exportMatch) {
      console.warn(`Warning: Could not find export in ${fileName}`);
      return null;
    }
    
    const exportName = exportMatch[1];
    
    // Extract the object content between the braces
    // This is a simple parser - it finds the opening brace after the export
    let braceCount = 0;
    let objectStart = -1;
    let objectEnd = -1;
    let inString = false;
    let stringChar = null;
    
    for (let i = exportMatch.index + exportMatch[0].length; i < content.length; i++) {
      const char = content[i];
      const prevChar = i > 0 ? content[i - 1] : '';
      
      // Handle strings (both single and double quotes, and template literals)
      if (!inString && (char === '"' || char === "'" || char === '`')) {
        inString = true;
        stringChar = char;
      } else if (inString && char === stringChar && prevChar !== '\\') {
        inString = false;
        stringChar = null;
      }
      
      if (!inString) {
        if (char === '{') {
          if (braceCount === 0) {
            objectStart = i;
          }
          braceCount++;
        } else if (char === '}') {
          braceCount--;
          if (braceCount === 0) {
            objectEnd = i;
            break;
          }
        }
      }
    }
    
    if (objectStart === -1 || objectEnd === -1) {
      console.warn(`Warning: Could not parse object in ${fileName}`);
      return null;
    }
    
    // Extract the object string and evaluate it safely using vm
    const objectString = content.substring(objectStart, objectEnd + 1);
    
    // Use vm.createContext for safer evaluation
    let entryData;
    try {
      const context = vm.createContext({});
      entryData = vm.runInContext(`(${objectString})`, context);
    } catch (e) {
      console.warn(`Warning: Could not evaluate object in ${fileName}:`, e.message);
      return null;
    }
    
    // Extract ID from filename (format: {id}_{name}.js)
    const idMatch = fileName.match(/^(\d+)_/);
    const idFromFile = idMatch ? parseInt(idMatch[1]) : null;
    
    // Use ID from file if available, otherwise use ID from object
    const id = idFromFile || entryData.id;
    
    return {
      id,
      file: fileName,
      exportName,
      title: entryData.title || 'Untitled',
      date: entryData.date || '',
      timestamp: entryData.timestamp || '',
      rating: entryData.rating || 0,
      location: entryData.location || '',
      tags: entryData.tags || []
    };
  } catch (error) {
    console.error(`Error parsing ${fileName}:`, error.message);
    return null;
  }
}

// Generate manifest from all entry files
function generateManifest() {
  console.log('Generating manifest...');
  
  // Ensure entries directory exists
  if (!fs.existsSync(ENTRIES_DIR)) {
    console.error(`Error: Entries directory does not exist: ${ENTRIES_DIR}`);
    process.exit(1);
  }
  
  const files = fs.readdirSync(ENTRIES_DIR);
  const entryFiles = files.filter(file => 
    file.endsWith('.js') && 
    file !== 'manifest.js' && 
    file !== 'index.js' &&
    file !== 'template.js' &&
    /^\d+_/.test(file) // Only files starting with number_
  );
  
  console.log(`Found ${entryFiles.length} entry files`);
  
  const entries = [];
  
  for (const file of entryFiles) {
    const filePath = path.join(ENTRIES_DIR, file);
    const entry = parseEntryFile(filePath, file);
    
    if (entry) {
      entries.push(entry);
    }
  }
  
  // Sort by ID
  entries.sort((a, b) => a.id - b.id);
  
  if (entries.length === 0) {
    console.warn('Warning: No entries found. Creating empty manifest.');
  }
  
  // Generate manifest content
  const manifestContent = `// Auto-generated manifest of all entries
// This file contains metadata for all entries to enable lazy loading
// Note: published status is now stored in individual entry files
// DO NOT EDIT THIS FILE MANUALLY - it is auto-generated by scripts/generate-manifest.js
export const entriesManifest = [
${entries.map(entry => `  {
    id: ${entry.id},
    file: '${entry.file}',
    exportName: '${entry.exportName}',
    title: ${JSON.stringify(entry.title)},
    date: ${JSON.stringify(entry.date)},
    timestamp: ${JSON.stringify(entry.timestamp)},
    rating: ${entry.rating},
    location: ${JSON.stringify(entry.location)},
    tags: ${JSON.stringify(entry.tags)}
  }`).join(',\n')}
];

/**
 * Get entry metadata by ID
 * @param {number} id - Entry ID
 * @returns {Object|undefined} - Entry metadata or undefined if not found
 */
export const getEntryMetadata = (id) => {
  return entriesManifest.find(entry => entry.id === id);
};

/**
 * Get all unique tags from all entries
 * @returns {Array<string>} - Sorted array of unique tags
 */
export const getAllTags = () => {
  const allTags = new Set();
  entriesManifest.forEach(entry => {
    if (entry.tags && Array.isArray(entry.tags)) {
      entry.tags.forEach(tag => allTags.add(tag));
    }
  });
  return Array.from(allTags).sort();
};

/**
 * Get all unique locations from all entries
 * @returns {Array<string>} - Sorted array of unique locations
 */
export const getAllLocations = () => {
  const allLocations = new Set();
  entriesManifest.forEach(entry => {
    if (entry.location) {
      allLocations.add(entry.location);
    }
  });
  return Array.from(allLocations).sort();
};
`;
  
  // Write manifest file
  try {
    // Ensure the directory exists
    const manifestDir = path.dirname(MANIFEST_FILE);
    if (!fs.existsSync(manifestDir)) {
      fs.mkdirSync(manifestDir, { recursive: true });
    }
    
    fs.writeFileSync(MANIFEST_FILE, manifestContent, 'utf8');
    
    // Verify the file was written and exists
    if (!fs.existsSync(MANIFEST_FILE)) {
      console.error(`Error: Manifest file was not created at ${MANIFEST_FILE}`);
      process.exit(1);
    }
    
    const writtenContent = fs.readFileSync(MANIFEST_FILE, 'utf8');
    if (writtenContent !== manifestContent) {
      console.error('Error: Manifest file was not written correctly');
      process.exit(1);
    }
    
    console.log(`âœ“ Manifest generated with ${entries.length} entries at ${MANIFEST_FILE}`);
  } catch (error) {
    console.error(`Error writing manifest file to ${MANIFEST_FILE}:`, error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

// Watch for file changes
function watchEntries() {
  console.log('Watching for changes in entries folder...');
  
  // Generate initial manifest
  generateManifest();
  
  // Try to use chokidar if available, otherwise fall back to fs.watch
  let watcher;
  try {
    const chokidar = require('chokidar');
    watcher = chokidar.watch(path.join(ENTRIES_DIR, '*.js'), {
      ignored: ['**/manifest.js', '**/index.js', '**/template.js'],
      persistent: true,
      ignoreInitial: true
    });
    
    watcher.on('all', (event, filePath) => {
      const filename = path.basename(filePath);
      console.log(`\nFile ${event}: ${filename}`);
      setTimeout(() => {
        generateManifest();
      }, 100);
    });
    
    console.log('Using chokidar for file watching (better performance)');
  } catch (e) {
    // Fall back to fs.watch if chokidar is not available
    console.log('Using fs.watch (install chokidar for better performance: npm install --save-dev chokidar)');
    fs.watch(ENTRIES_DIR, { recursive: false }, (eventType, filename) => {
      if (filename && filename.endsWith('.js') && 
          filename !== 'manifest.js' && 
          filename !== 'index.js' && 
          filename !== 'template.js' &&
          /^\d+_/.test(filename)) {
        console.log(`\nFile ${eventType}: ${filename}`);
        setTimeout(() => {
          generateManifest();
        }, 100);
      }
    });
  }
  
  console.log('Press Ctrl+C to stop watching...');
}

// Run based on command line argument
const mode = process.argv[2];

if (mode === 'watch') {
  watchEntries();
} else {
  generateManifest();
}

